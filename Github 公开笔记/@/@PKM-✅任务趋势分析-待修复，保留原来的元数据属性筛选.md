ä½ è¦æ ¹æ®æˆ‘çš„éœ€æ±‚å®Œå–„ä»£ç ï¼Œä¸å…è®¸å‡ºé”™
1. æ˜¾ç¤ºç©ºç™½çš„åæ ‡
2. å¯è¯»æ€§ä¼˜åŒ–
3. ä¼˜åŒ–è¿™ä¸ªç‰ˆæœ¬çš„ä»»åŠ¡è¶‹åŠ¿ç»Ÿè®¡ï¼Œä½¿å…¶éå¸¸æ­£ç¡®çš„

Obsidian ç”¨chartsçš„type: 'line'ï¼Œå·²ç»ä»2ä¸ªå±æ€§ä¸­è·å–æ•æ‰åˆ°æ¥ä¹‹ä¸åŒç¬”è®°é¡µé¢çš„ä»»åŠ¡ç¬¦å·çš„æ—¥æœŸï¼Œå½¢æˆæŠ˜çº¿å›¾

- [[åå‘ä»»åŠ¡ï¼ˆåŒ…å«3 ä¸ªç‰ˆæœ¬ï¼‰ 251215]] <span class="timer-p" id="ea55oi1j" data-dur="11111" data-ts="1765243194">ã€â³20:00:00 ã€‘</span>â• 2025-12-09 â³ 2025-12-09
- è¿™æ¡ä»»åŠ¡åŒ…å«3ä¸ªæ—¥æœŸæ•°é‡ï¼š12-05â•åˆ›å»ºï¼Œ12-06â³è®¡åˆ’è®¡æ—¶ï¼Œ12-09âœ…å®Œæˆ  â• 2025-12-05 â³ 2025-12-06 âœ… 2025-12-09
è®¡æ—¶æ˜¾ç¤ºåœ¨â³è®¡åˆ’è®¡æ—¶ï¼šä¸“æ³¨ç´¯è®¡ï¼Œâ³ 2025-12-08 ç´¯è®¡2å°æ—¶
- ä»»åŠ¡2 <span class="timer-p" id="ea55oi1j" data-dur="1111" data-ts="1765243194">ã€â³01:00:00 ã€‘</span> â³ 2025-12-08
- ä»»åŠ¡1 <span class="timer-p" id="ea55oi1j" data-dur="0" data-ts="1765243194">ã€â³01:00:00 ã€‘</span> â³ 2025-12-08 âœ… 2025-12-09
- [[@PKM-è¡ŒåŠ¨è®°å½•]]  +100æ¬¡ #ğŸ“ŠIè¾“å…¥âŒ›ï¸å·¥ä½œ   [duration:: 5m]  [startTime:: 13:25] â³ 2025-12-09 ğŸ“… 2025-12-09 âœ… 2025-12-09
- ä»»åŠ¡ <span class="timer-p" id="0a7jktwa" data-dur="0" data-ts="1765257908">ã€â³01:00:00 ã€‘</span> â• 2025-12-02 â³ 2025-12-02 âœ… 2025-12-09
		- æ–¹æ¡ˆæ—¥æœŸ ğŸ 2025-12-09

åæ ‡ï¼šèŒƒå›´æ—¥æœŸ
æŠ˜çº¿ä¸€ï¼šâ• åˆ›å»ºæ—¥æœŸ
æŠ˜çº¿äºŒï¼šğŸ æ–¹æ¡ˆæ—¥æœŸ
æŠ˜çº¿ä¸‰ï¼šâœ… å®Œæˆæ—¥æœŸ
æŠ˜çº¿å››ï¼šé‡å¤é‡
é‡å¤æ¬¡æ•°å°±æ˜¯+å‡ æ¬¡ï¼Œä¾‹å¦‚ä¸“æ³¨æ—¶é•¿2å°æ—¶æ—¶é—´å†…ï¼Œ+9æ¬¡
æŠ˜çº¿äº”ï¼šä¸“æ³¨æ—¶é•¿

ä½ è¦æ ¹æ®æˆ‘çš„éœ€æ±‚å®Œå–„ä»£ç ï¼Œä¸å…è®¸å‡ºé”™
ä¿®å¤é‡å¤æ¬¡æ•°è®¡ç®—ï¼šä¾‹å¦‚è¿™é‡Œæ˜¯+9æ¬¡
- [[ä¹ æƒ¯å…»æˆ]] <span class="timer-p" id="yoc5jstm" data-dur="0" data-ts="1765243389">ã€â³02:00:00 ã€‘</span> +9æ¬¡ â³ 2025-12-09
- ä¿®å¤ä¸“æ³¨æ—¶é•¿è®¡ç®—ï¼šä¾‹å¦‚è¿™é‡Œæ˜¯12-09æ›²çº¿åæ ‡ï¼Œä¸“æ³¨2å°æ—¶ä¸“æ³¨<span class="timer-p" id="ea55oi1j" data-dur="0" data-ts="1765243194">ã€â³02:00:00 ã€‘</span>
 - [[ä¹ æƒ¯å…»æˆ]] <span class="timer-p" id="yoc5jstm" data-dur="0" data-ts="1765243389">ã€â³02:00:00 ã€‘</span> +9æ¬¡ â³ 2025-12-09



åœ¨ Obsidianç¬”è®°.mdé¡µé¢ä¸­ï¼Œdataviewjså’Œchartsåˆ¶ä½œä¸€ä¸ªä»»åŠ¡tasksè¶‹åŠ¿æŸ¥è¯¢ï¼ŒåŸºäº2ä¸ªæ—¥æœŸå±æ€§[å¼€å§‹æ—¥æœŸ][ç»“æŸæ—¥æœŸ]çš„åŠ¨æ€èŒƒå›´ï¼Œè·å–æ‰€æœ‰é¡µé¢ç¬¦åˆæ¡ä»¶çš„ä»»åŠ¡æ—¥æœŸè¶‹åŠ¿ï¼Œæ”¯æŒç©ºæ—¥æœŸåæ ‡ä¹Ÿè¦æ˜¾ç¤ºæ•°æ®
- åˆ›å»ºæ—¥æœŸ â• 2025-12-01
- åˆ›å»ºæ—¥æœŸ â• 2025-12-03
- å®Œæˆæ—¥æœŸ âœ… 2025-12-01
- å®Œæˆæ—¥æœŸ âœ… 2025-12-03

åœ¨ Obsidian ä¸­åˆ¶ä½œä¸€ä¸ªæ›²çº¿å›¾ï¼Œå±•ç¤ºä»»åŠ¡çš„æ—¥æœŸè¶‹åŠ¿å³å¯ï¼Œå¦‚æœé‚£å¤©æ—¥æœŸæ²¡æœ‰ä»»åŠ¡æ—¥æœŸï¼Œä¹Ÿè¦æ˜¾ç¤ºæ—¥æœŸåæ ‡
ä½ è¦æ ¹æ®æˆ‘çš„éœ€æ±‚å®Œå–„ä»£ç Obsidian dataviewjså’Œchartsä»£ç ï¼Œä¸å…è®¸å‡ºé”™
åˆ¶ä½œä¸‰ä¸ªç‹¬ç«‹ä»£ç ï¼šç¬¬ä¸€ä¸ªä»£ç çš„åæ ‡æŒ‰å‘¨ï¼Œç¬¬äºŒä¸ªä»£ç çš„åæ ‡æŒ‰æœˆï¼Œç¬¬ä¸‰ä¸ªä»£ç çš„åæ ‡æŒ‰å­£
ä¸“æ³¨ç´¯ç§¯ç”¨1å°æ—¶ï¼Œè€Œä¸æ˜¯ data-dur="0"çš„ç§’ç´¯ç§¯
- [[åå‘ä»»åŠ¡ï¼ˆåŒ…å«3 ä¸ªç‰ˆæœ¬ï¼‰ 251215]] <span class="timer-p" id="511sq8sr" data-dur="0" data-ts="1765264900">ã€â³01:00:00 ã€‘</span> â• 2025-12-09 â³ 2025-12-09
```dataviewjs
// ==================== ä»»åŠ¡è¶‹åŠ¿æŠ˜çº¿å›¾ï¼ˆå·²ä¼˜åŒ–ï¼‰ ====================
// ä¿®å¤ï¼šæ˜¾ç¤ºç©ºç™½åæ ‡ï¼Œå¯è¯»æ€§ä¼˜åŒ–ï¼Œæ­£ç¡®ç»Ÿè®¡ä»»åŠ¡è¶‹åŠ¿

// 1. è·å–å½“å‰ç¬”è®°çš„æ—¥æœŸèŒƒå›´
const currentFile = dv.current();
const startDate = currentFile['è¿›è¡Œæ—¥æœŸ'] ? dv.date(currentFile['è¿›è¡Œæ—¥æœŸ']) : dv.date('2021-01-01');
const endDate = currentFile['æˆªæ­¢æ—¥æœŸ'] ? dv.date(currentFile['æˆªæ­¢æ—¥æœŸ']) : dv.date('2021-01-30');

// 2. ç”Ÿæˆæ—¥æœŸèŒƒå›´å†…çš„æ‰€æœ‰æ—¥æœŸï¼ˆç¡®ä¿åŒ…å«ç©ºç™½åæ ‡ï¼‰
function getDateRange(start, end) {
    const dates = [];
    let current = dv.date(start);
    const endDateObj = dv.date(end);
    
    while (current <= endDateObj) {
        dates.push(current.toISODate());
        current = current.plus({ days: 1 });
    }
    return dates;
}

// 3. è·å–æ‰€æœ‰ä»»åŠ¡ï¼ˆä»å½“å‰æ–‡ä»¶ï¼‰
function getAllTasks() {
    try {
        const currentFileTasks = dv.current().file.tasks || [];
        console.log(`ğŸ“‹ æ‰¾åˆ° ${currentFileTasks.length} ä¸ªä»»åŠ¡`);
        return currentFileTasks;
    } catch (error) {
        console.error("âŒ è·å–ä»»åŠ¡å¤±è´¥:", error);
        return [];
    }
}

// 4. æå–æ—¥æœŸå‡½æ•°ï¼ˆä¼˜åŒ–å¯è¯»æ€§ï¼‰
function extractDate(text, pattern) {
    const match = text.match(pattern);
    return match ? match[1] : null;
}

// 5. æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
function extractRepeatCount(text) {
    const repeatMatch = text.match(/\+(\d+)æ¬¡/);
    return repeatMatch ? parseInt(repeatMatch[1]) : 0;
}

// 6. æå–ä¸“æ³¨æ—¶é•¿ï¼ˆä¿®å¤ï¼šä»å¤šä¸ªæ¥æºæå–ï¼‰
function extractFocusDuration(text) {
    let totalHours = 0;
    
    // æ–¹æ³•1ï¼šä»ã€â³HH:MM:SSã€‘æ ¼å¼æå–
    const focusMatch = text.match(/ã€â³(\d{2}):(\d{2}):(\d{2})ã€‘/);
    if (focusMatch) {
        const hours = parseInt(focusMatch[1]);
        const minutes = parseInt(focusMatch[2]);
        const seconds = parseInt(focusMatch[3]);
        totalHours += hours + minutes/60 + seconds/3600;
    }
    
    // æ–¹æ³•2ï¼šä»data-durå±æ€§æå–ï¼ˆç§’è½¬å°æ—¶ï¼‰
    const durMatch = text.match(/data-dur="(\d+)"/);
    if (durMatch) {
        const seconds = parseInt(durMatch[1]);
        totalHours += seconds / 3600;
    }
    
    return totalHours;
}

// ä¸»æ‰§è¡Œé€»è¾‘
const allTasks = getAllTasks();
const dateRange = getDateRange(startDate, endDate);

// 7. åˆå§‹åŒ–ç»Ÿè®¡æ•°æ®
const taskStats = {
    'åˆ›å»ºæ—¥æœŸ': {},    // â• æ ‡è®°
    'æ–¹æ¡ˆæ—¥æœŸ': {},    // ğŸ æ ‡è®°
    'å®Œæˆæ—¥æœŸ': {},    // âœ… æ ‡è®°
    'é‡å¤æ¬¡æ•°': {},    // +Xæ¬¡
    'ä¸“æ³¨æ—¶é•¿': {}     // â³ æ—¶é•¿
};

// åˆå§‹åŒ–æ‰€æœ‰æ—¥æœŸä¸º0ï¼ˆç¡®ä¿ç©ºç™½åæ ‡æ˜¾ç¤ºï¼‰
dateRange.forEach(date => {
    taskStats['åˆ›å»ºæ—¥æœŸ'][date] = 0;
    taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] = 0;
    taskStats['å®Œæˆæ—¥æœŸ'][date] = 0;
    taskStats['é‡å¤æ¬¡æ•°'][date] = 0;
    taskStats['ä¸“æ³¨æ—¶é•¿'][date] = 0;
});

// 8. ç»Ÿè®¡ä»»åŠ¡æ•°æ®
allTasks.forEach((task, index) => {
    try {
        const text = task.text || '';
        const status = task.status || '';
        
        // è°ƒè¯•ä¿¡æ¯
        if (index < 5) {
            console.log(`ğŸ” å¤„ç†ä»»åŠ¡ ${index+1}: ${text.substring(0, 80)}...`);
        }
        
        // 1. æå–åˆ›å»ºæ—¥æœŸï¼ˆâ•æ ‡è®°ï¼‰
        const createDate = extractDate(text, /â•\s*(\d{4}-\d{2}-\d{2})/);
        if (createDate && dateRange.includes(createDate)) {
            taskStats['åˆ›å»ºæ—¥æœŸ'][createDate] += 1;
            console.log(`   â• åˆ›å»ºæ—¥æœŸ: ${createDate}`);
        }
        
        // 2. æå–æ–¹æ¡ˆæ—¥æœŸï¼ˆğŸæ ‡è®°ï¼‰
        const solutionDate = extractDate(text, /ğŸ\s*(\d{4}-\d{2}-\d{2})/);
        if (solutionDate && dateRange.includes(solutionDate)) {
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][solutionDate] += 1;
            console.log(`   ğŸ æ–¹æ¡ˆæ—¥æœŸ: ${solutionDate}`);
        }
        
        // 3. æå–å®Œæˆæ—¥æœŸï¼ˆâœ…æ ‡è®°ï¼‰
        const completeDate = extractDate(text, /âœ…\s*(\d{4}-\d{2}-\d{2})/);
        if (completeDate && dateRange.includes(completeDate)) {
            taskStats['å®Œæˆæ—¥æœŸ'][completeDate] += 1;
            console.log(`   âœ… å®Œæˆæ—¥æœŸ: ${completeDate}`);
        }
        
        // 4. æå–è®¡åˆ’æ—¥æœŸï¼ˆâ³æ ‡è®°ï¼‰- ç”¨äºé‡å¤æ¬¡æ•°å’Œä¸“æ³¨æ—¶é•¿
        const planDate = extractDate(text, /â³\s*(\d{4}-\d{2}-\d{2})/);
        if (planDate && dateRange.includes(planDate)) {
            // 4.1 æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
            const repeatCount = extractRepeatCount(text);
            if (repeatCount > 0) {
                taskStats['é‡å¤æ¬¡æ•°'][planDate] += repeatCount;
                console.log(`   ğŸ”„ é‡å¤æ¬¡æ•°: ${planDate} -> +${repeatCount}æ¬¡`);
            }
            
            // 4.2 æå–ä¸“æ³¨æ—¶é•¿
            const focusHours = extractFocusDuration(text);
            if (focusHours > 0) {
                taskStats['ä¸“æ³¨æ—¶é•¿'][planDate] += focusHours;
                console.log(`   â±ï¸ ä¸“æ³¨æ—¶é•¿: ${planDate} -> ${focusHours.toFixed(2)}å°æ—¶`);
            }
        }
        
    } catch (error) {
        console.error(`âŒ å¤„ç†ä»»åŠ¡æ—¶å‡ºé”™: ${error.message}`);
    }
});

// 9. æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
const hasData = Object.values(taskStats).some(category => 
    Object.values(category).some(count => count > 0)
);

// å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä½†ä¸å¡«å……ç¤ºä¾‹æ•°æ®ï¼ˆä¿æŒç©ºç™½åæ ‡ï¼‰
if (!hasData) {
    console.warn("âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼Œå°†æ˜¾ç¤ºç©ºç™½å›¾è¡¨");
}

// 10. ç”Ÿæˆæ—¥æœŸæ ‡ç­¾ï¼ˆä¼˜åŒ–å¯è¯»æ€§ï¼‰
function getDateLabels(dates) {
    if (dates.length === 0) return [];
    
    const start = moment(dates[0]);
    const end = moment(dates[dates.length-1]);
    const daysDiff = end.diff(start, 'days');
    
    if (daysDiff <= 7) {
        // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map(date => {
            const dateObj = moment(date);
            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
            return `${dateObj.format('MM-DD')}(${dayOfWeek})`;
        });
    } else if (daysDiff <= 31) {
        // ä¸€ä¸ªæœˆå†…ï¼šæ˜¾ç¤ºæ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map((date, index) => {
            if (index % 2 === 0) {
                const dateObj = moment(date);
                return dateObj.format('MM-DD');
            }
            return '';
        });
    } else {
        // æ›´é•¿æ—¶é—´ï¼šæ¯å‘¨æ˜¾ç¤ºä¸€ä¸ªç‚¹
        const labels = [];
        for (let i = 0; i < dates.length; i += 7) {
            const dateObj = moment(dates[i]);
            labels.push(dateObj.format('MM-DD'));
        }
        return labels;
    }
}

// 11. åˆ›å»ºå›¾è¡¨
function createChart() {
    // æ˜¾ç¤ºæ ‡é¢˜
    dv.header(3, `ğŸ“ˆ ä»»åŠ¡è¶‹åŠ¿åˆ†æ (${moment(startDate).format('YYYY-MM-DD')} è‡³ ${moment(endDate).format('YYYY-MM-DD')})`);
    
    // æ£€æŸ¥Chartsæ’ä»¶æ˜¯å¦å¯ç”¨
    if (typeof window.renderChart === 'undefined') {
        dv.paragraph("âš ï¸ **Chartsæ’ä»¶æœªå¯ç”¨** - è¯·å®‰è£…å¹¶å¯ç”¨ Obsidian Charts æ’ä»¶");
        return;
    }
    
    // å‡†å¤‡æ—¥æœŸæ ‡ç­¾
    const dateLabels = getDateLabels(dateRange);
    
    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const chartData = {
        type: 'line',
        data: {
            labels: dateLabels,
            datasets: [
                {
                    label: 'â• åˆ›å»ºæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['åˆ›å»ºæ—¥æœŸ'][date]),
                    borderColor: '#3B82F6', // è“è‰²
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#3B82F6'
                },
                {
                    label: 'ğŸ æ–¹æ¡ˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date]),
                    borderColor: '#F59E0B', // æ©™è‰²
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#F59E0B'
                },
                {
                    label: 'âœ… å®Œæˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['å®Œæˆæ—¥æœŸ'][date]),
                    borderColor: '#10B981', // ç»¿è‰²
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#10B981'
                },
                {
                    label: 'ğŸ”„ é‡å¤æ¬¡æ•°',
                    data: dateRange.map(date => taskStats['é‡å¤æ¬¡æ•°'][date]),
                    borderColor: '#EF4444', // çº¢è‰²
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#EF4444'
                },
                {
                    label: 'â±ï¸ ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                    data: dateRange.map(date => taskStats['ä¸“æ³¨æ—¶é•¿'][date]),
                    borderColor: '#8B5CF6', // ç´«è‰²
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#8B5CF6',
                    yAxisID: 'y1'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: 12,
                        padding: 10,
                        font: {
                            size: 11
                        },
                        usePointStyle: true
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleFont: { size: 12 },
                    bodyFont: { size: 11 },
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            let value = context.parsed.y;
                            
                            if (label.includes('ä¸“æ³¨æ—¶é•¿')) {
                                return `${label}: ${value.toFixed(2)} å°æ—¶`;
                            } else if (label.includes('é‡å¤æ¬¡æ•°')) {
                                return `${label}: ${value} æ¬¡`;
                            } else {
                                return `${label}: ${value} ä¸ª`;
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        maxRotation: 45,
                        minRotation: 0
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        stepSize: 1,
                        callback: function(value) {
                            return Number.isInteger(value) ? value : '';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä»»åŠ¡æ•°é‡',
                        font: {
                            size: 11
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false,
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        callback: function(value) {
                            return value.toFixed(1) + 'h';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                        font: {
                            size: 11
                        }
                    }
                }
            }
        }
    };
    
    // åˆ›å»ºå›¾è¡¨å®¹å™¨
    const chartContainer = this.container.createEl('div', {
        cls: 'task-trend-chart-container'
    });
    
    chartContainer.style.height = '500px';
    chartContainer.style.width = '100%';
    chartContainer.style.margin = '15px 0';
    chartContainer.style.padding = '10px';
    chartContainer.style.borderRadius = '6px';
    chartContainer.style.border = '1px solid var(--background-modifier-border)';
    chartContainer.style.backgroundColor = 'var(--background-primary)';
    chartContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
    
    // æ¸²æŸ“å›¾è¡¨
    try {
        window.renderChart(chartData, chartContainer);
        
        // æ˜¾ç¤ºæ•°æ®æ‘˜è¦
        const summaryLines = [];
        Object.entries(taskStats).forEach(([category, data]) => {
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            if (total > 0) {
                if (category === 'ä¸“æ³¨æ—¶é•¿') {
                    summaryLines.push(`${category}: ${total.toFixed(2)}å°æ—¶`);
                } else if (category === 'é‡å¤æ¬¡æ•°') {
                    summaryLines.push(`${category}: ${total}æ¬¡`);
                } else {
                    summaryLines.push(`${category}: ${total}ä¸ª`);
                }
            }
        });
        
        if (summaryLines.length > 0) {
            dv.paragraph(`ğŸ“Š **æ•°æ®æ‘˜è¦**: ${summaryLines.join(' | ')}`);
        } else {
            dv.paragraph("ğŸ“Š **æ•°æ®æ‘˜è¦**: æš‚æ— æ•°æ®");
        }
        
        // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
        if (!hasData) {
            dv.paragraph("â„¹ï¸ **æç¤º**: å½“å‰æ²¡æœ‰æ‰¾åˆ°ä»»åŠ¡æ•°æ®ã€‚è¯·ç¡®ä¿ï¼š");
            dv.paragraph("1. ä»»åŠ¡æ ¼å¼æ­£ç¡®ï¼ˆåŒ…å«â•ã€ğŸã€âœ…ã€â³ã€+Xæ¬¡ç­‰æ ‡è®°ï¼‰");
            dv.paragraph("2. æ—¥æœŸåœ¨æŒ‡å®šèŒƒå›´å†…ï¼ˆ2021-01-01 è‡³ 2021-01-30ï¼‰");
            dv.paragraph("3. å›¾è¡¨å°†æ˜¾ç¤ºç©ºç™½åæ ‡ï¼Œç›´åˆ°æœ‰æ•°æ®");
        }
        
    } catch (error) {
        console.error("âŒ å›¾è¡¨æ¸²æŸ“å¤±è´¥:", error);
        dv.paragraph("âŒ **å›¾è¡¨æ¸²æŸ“å¤±è´¥**: " + error.message);
        displayDataTable();
    }
}

// 12. æ˜¾ç¤ºæ•°æ®è¡¨æ ¼ï¼ˆå¤‡ç”¨ï¼‰
function displayDataTable() {
    dv.header(4, "ğŸ“‹ è¯¦ç»†æ•°æ®è¡¨æ ¼");
    
    let tableData = [["æ—¥æœŸ", "åˆ›å»ºæ—¥æœŸ", "æ–¹æ¡ˆæ—¥æœŸ", "å®Œæˆæ—¥æœŸ", "é‡å¤æ¬¡æ•°", "ä¸“æ³¨æ—¶é•¿(å°æ—¶)"]];
    
    dateRange.forEach(date => {
        const dateObj = moment(date);
        const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
        
        tableData.push([
            `${dateObj.format('MM-DD')}(${dayOfWeek})`,
            taskStats['åˆ›å»ºæ—¥æœŸ'][date],
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date],
            taskStats['å®Œæˆæ—¥æœŸ'][date],
            taskStats['é‡å¤æ¬¡æ•°'][date],
            taskStats['ä¸“æ³¨æ—¶é•¿'][date].toFixed(2)
        ]);
    });
    
    dv.table(tableData[0], tableData.slice(1));
}

// 13. æ‰§è¡Œä¸»å‡½æ•°
try {
    console.log("ğŸš€ å¼€å§‹æ‰§è¡Œä»»åŠ¡è¶‹åŠ¿åˆ†æ...");
    console.log(`ğŸ“… æ—¥æœŸèŒƒå›´: ${dateRange[0]} è‡³ ${dateRange[dateRange.length-1]} (å…±${dateRange.length}å¤©)`);
    console.log(`ğŸ“ ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
    
    createChart.call(this);
    
    console.log("âœ… ä»»åŠ¡è¶‹åŠ¿åˆ†æå®Œæˆ");
} catch (error) {
    console.error("âŒ æ‰§è¡Œå¤±è´¥:", error);
    dv.paragraph("âŒ **ä»£ç æ‰§è¡Œå¤±è´¥**: " + error.message);
    
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    dv.paragraph("**è°ƒè¯•ä¿¡æ¯**:");
    dv.paragraph(`- æ—¥æœŸèŒƒå›´: ${dateRange.length} å¤©`);
    dv.paragraph(`- ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
}
```

```dataviewjs
// ==================== ä»»åŠ¡è¶‹åŠ¿æŠ˜çº¿å›¾ï¼ˆä¿®å¤ç©ºç™½åæ ‡æ˜¾ç¤ºï¼‰ ====================
// ä¿®å¤ï¼šæ­£ç¡®æ˜¾ç¤ºç©ºç™½æ—¥æœŸå’Œä»»åŠ¡æ›²çº¿ï¼Œä¼˜åŒ–ç»Ÿè®¡é€»è¾‘

// 1. è·å–å½“å‰ç¬”è®°çš„æ—¥æœŸèŒƒå›´
const currentFile = dv.current();
const startDate = currentFile['è¿›è¡Œæ—¥æœŸ'] ? dv.date(currentFile['è¿›è¡Œæ—¥æœŸ']) : dv.date('2025-12-07');
const endDate = currentFile['æˆªæ­¢æ—¥æœŸ'] ? dv.date(currentFile['æˆªæ­¢æ—¥æœŸ']) : dv.date('2025-12-09');

// 2. ç”Ÿæˆæ—¥æœŸèŒƒå›´å†…çš„æ‰€æœ‰æ—¥æœŸï¼ˆç¡®ä¿åŒ…å«ç©ºç™½åæ ‡ï¼‰
function getDateRange(start, end) {
    const dates = [];
    let current = dv.date(start);
    const endDateObj = dv.date(end);
    
    while (current <= endDateObj) {
        dates.push(current.toISODate());
        current = current.plus({ days: 1 });
    }
    return dates;
}

// 3. è·å–æ‰€æœ‰ä»»åŠ¡ï¼ˆä»å½“å‰æ–‡ä»¶ï¼‰
function getAllTasks() {
    try {
        const currentFileTasks = dv.current().file.tasks || [];
        console.log(`ğŸ“‹ æ‰¾åˆ° ${currentFileTasks.length} ä¸ªä»»åŠ¡`);
        if (currentFileTasks.length > 0) {
            console.log("ğŸ“ ä»»åŠ¡ç¤ºä¾‹:", currentFileTasks.slice(0, 3).map(t => t.text?.substring(0, 60)));
        }
        return currentFileTasks;
    } catch (error) {
        console.error("âŒ è·å–ä»»åŠ¡å¤±è´¥:", error);
        return [];
    }
}

// 4. æå–æ—¥æœŸå‡½æ•°
function extractDate(text, pattern) {
    const match = text.match(pattern);
    return match ? match[1] : null;
}

// 5. æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
function extractRepeatCount(text) {
    // å…ˆå°è¯•ç²¾ç¡®åŒ¹é… +Xæ¬¡ æ ¼å¼
    const repeatMatch = text.match(/\+(\d+)æ¬¡/);
    if (repeatMatch) {
        return parseInt(repeatMatch[1]);
    }
    return 0;
}

// 6. æå–ä¸“æ³¨æ—¶é•¿ï¼ˆä»å¤šä¸ªæ¥æºæå–ï¼‰
function extractFocusDuration(text) {
    let totalHours = 0;
    
    // æ–¹æ³•1ï¼šä»ã€â³HH:MM:SSã€‘æ ¼å¼æå–
    const focusMatch = text.match(/ã€â³(\d{2}):(\d{2}):(\d{2})ã€‘/);
    if (focusMatch) {
        const hours = parseInt(focusMatch[1]);
        const minutes = parseInt(focusMatch[2]);
        const seconds = parseInt(focusMatch[3]);
        totalHours = hours + minutes/60 + seconds/3600;
        console.log(`â±ï¸ ä»ã€â³HH:MM:SSã€‘æå–ä¸“æ³¨æ—¶é•¿: ${totalHours.toFixed(2)}å°æ—¶`);
    }
    
    // æ–¹æ³•2ï¼šä»data-durå±æ€§æå–ï¼ˆç§’è½¬å°æ—¶ï¼‰
    const durMatch = text.match(/data-dur="(\d+)"/);
    if (durMatch) {
        const seconds = parseInt(durMatch[1]);
        const hours = seconds / 3600;
        console.log(`â±ï¸ ä»data-duræå–ä¸“æ³¨æ—¶é•¿: ${hours.toFixed(2)}å°æ—¶`);
        return hours; // å¦‚æœæœ‰data-durï¼Œä¼˜å…ˆä½¿ç”¨å®ƒ
    }
    
    return totalHours;
}

// ä¸»æ‰§è¡Œé€»è¾‘
const allTasks = getAllTasks();
const dateRange = getDateRange(startDate, endDate);

console.log(`ğŸ“… æ—¥æœŸèŒƒå›´: ${dateRange[0]} è‡³ ${dateRange[dateRange.length-1]} (å…±${dateRange.length}å¤©)`);
console.log("ğŸ“Š æ‰€æœ‰æ—¥æœŸ:", dateRange);

// 7. åˆå§‹åŒ–ç»Ÿè®¡æ•°æ®ï¼ˆä½¿ç”¨æ›´ç›´è§‚çš„é”®åï¼‰
const taskStats = {
    'åˆ›å»ºæ—¥æœŸ': {},    // â• æ ‡è®°
    'æ–¹æ¡ˆæ—¥æœŸ': {},    // ğŸ æ ‡è®°
    'å®Œæˆæ—¥æœŸ': {},    // âœ… æ ‡è®°
    'é‡å¤æ¬¡æ•°': {},    // +Xæ¬¡
    'ä¸“æ³¨æ—¶é•¿': {}     // â³ æ—¶é•¿
};

// åˆå§‹åŒ–æ‰€æœ‰æ—¥æœŸï¼ˆå…³é”®ï¼šç©ºç™½æ—¥æœŸåˆå§‹åŒ–ä¸º0ï¼Œç¡®ä¿Xè½´æ˜¾ç¤ºæ‰€æœ‰æ—¥æœŸï¼‰
dateRange.forEach(date => {
    // æ‰€æœ‰æ—¥æœŸéƒ½åˆå§‹åŒ–ä¸º0ï¼Œç¡®ä¿ç©ºç™½åæ ‡æ˜¾ç¤º
    taskStats['åˆ›å»ºæ—¥æœŸ'][date] = 0;
    taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] = 0;
    taskStats['å®Œæˆæ—¥æœŸ'][date] = 0;
    taskStats['é‡å¤æ¬¡æ•°'][date] = 0;
    taskStats['ä¸“æ³¨æ—¶é•¿'][date] = 0;
});

console.log("ğŸ“Š åˆå§‹åŒ–åçš„ç»Ÿè®¡æ•°æ®ç»“æ„:", taskStats);

// 8. ç»Ÿè®¡ä»»åŠ¡æ•°æ®ï¼ˆç²¾ç¡®ç»Ÿè®¡æ¯ä¸ªæ—¥æœŸï¼‰
allTasks.forEach((task, index) => {
    try {
        const text = task.text || '';
        const status = task.status || '';
        
        console.log(`\nğŸ” å¤„ç†ä»»åŠ¡ ${index+1}: ${text.substring(0, 80)}...`);
        
        // 1. æå–åˆ›å»ºæ—¥æœŸï¼ˆâ•æ ‡è®°ï¼‰
        const createDate = extractDate(text, /â•\s*(\d{4}-\d{2}-\d{2})/);
        if (createDate) {
            if (dateRange.includes(createDate)) {
                taskStats['åˆ›å»ºæ—¥æœŸ'][createDate] += 1;
                console.log(`   âœ… æ‰¾åˆ°åˆ›å»ºæ—¥æœŸ: ${createDate} (ç´¯è®¡: ${taskStats['åˆ›å»ºæ—¥æœŸ'][createDate]})`);
            } else {
                console.log(`   âš ï¸ åˆ›å»ºæ—¥æœŸ ${createDate} ä¸åœ¨ç»Ÿè®¡èŒƒå›´å†…`);
            }
        }
        
        // 2. æå–æ–¹æ¡ˆæ—¥æœŸï¼ˆğŸæ ‡è®°ï¼‰
        const solutionDate = extractDate(text, /ğŸ\s*(\d{4}-\d{2}-\d{2})/);
        if (solutionDate) {
            if (dateRange.includes(solutionDate)) {
                taskStats['æ–¹æ¡ˆæ—¥æœŸ'][solutionDate] += 1;
                console.log(`   âœ… æ‰¾åˆ°æ–¹æ¡ˆæ—¥æœŸ: ${solutionDate} (ç´¯è®¡: ${taskStats['æ–¹æ¡ˆæ—¥æœŸ'][solutionDate]})`);
            }
        }
        
        // 3. æå–å®Œæˆæ—¥æœŸï¼ˆâœ…æ ‡è®°ï¼‰
        const completeDate = extractDate(text, /âœ…\s*(\d{4}-\d{2}-\d{2})/);
        if (completeDate) {
            if (dateRange.includes(completeDate)) {
                taskStats['å®Œæˆæ—¥æœŸ'][completeDate] += 1;
                console.log(`   âœ… æ‰¾åˆ°å®Œæˆæ—¥æœŸ: ${completeDate} (ç´¯è®¡: ${taskStats['å®Œæˆæ—¥æœŸ'][completeDate]})`);
            }
        }
        
        // 4. æå–è®¡åˆ’æ—¥æœŸï¼ˆâ³æ ‡è®°ï¼‰- ç”¨äºé‡å¤æ¬¡æ•°å’Œä¸“æ³¨æ—¶é•¿
        const planDate = extractDate(text, /â³\s*(\d{4}-\d{2}-\d{2})/);
        if (planDate && dateRange.includes(planDate)) {
            // 4.1 æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
            const repeatCount = extractRepeatCount(text);
            if (repeatCount > 0) {
                taskStats['é‡å¤æ¬¡æ•°'][planDate] += repeatCount;
                console.log(`   ğŸ”„ æ‰¾åˆ°é‡å¤æ¬¡æ•°: ${planDate} -> +${repeatCount}æ¬¡ (ç´¯è®¡: ${taskStats['é‡å¤æ¬¡æ•°'][planDate]}æ¬¡)`);
            }
            
            // 4.2 æå–ä¸“æ³¨æ—¶é•¿
            const focusHours = extractFocusDuration(text);
            if (focusHours > 0) {
                taskStats['ä¸“æ³¨æ—¶é•¿'][planDate] += focusHours;
                console.log(`   â±ï¸ æ‰¾åˆ°ä¸“æ³¨æ—¶é•¿: ${planDate} -> ${focusHours.toFixed(2)}å°æ—¶ (ç´¯è®¡: ${taskStats['ä¸“æ³¨æ—¶é•¿'][planDate].toFixed(2)}å°æ—¶)`);
            }
        }
        
    } catch (error) {
        console.error(`âŒ å¤„ç†ä»»åŠ¡æ—¶å‡ºé”™: ${error.message}`);
    }
});

// 9. æ˜¾ç¤ºæœ€ç»ˆç»Ÿè®¡æ•°æ®
console.log("\nğŸ“Š æœ€ç»ˆç»Ÿè®¡æ•°æ®:");
dateRange.forEach(date => {
    const hasData = taskStats['åˆ›å»ºæ—¥æœŸ'][date] > 0 || 
                   taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] > 0 || 
                   taskStats['å®Œæˆæ—¥æœŸ'][date] > 0 ||
                   taskStats['é‡å¤æ¬¡æ•°'][date] > 0 ||
                   taskStats['ä¸“æ³¨æ—¶é•¿'][date] > 0;
    
    if (hasData) {
        console.log(`${date}: åˆ›å»º(${taskStats['åˆ›å»ºæ—¥æœŸ'][date]}), æ–¹æ¡ˆ(${taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date]}), å®Œæˆ(${taskStats['å®Œæˆæ—¥æœŸ'][date]}), é‡å¤(${taskStats['é‡å¤æ¬¡æ•°'][date]}æ¬¡), ä¸“æ³¨(${taskStats['ä¸“æ³¨æ—¶é•¿'][date].toFixed(2)}å°æ—¶)`);
    } else {
        console.log(`${date}: ç©ºç™½æ—¥æœŸ`);
    }
});

// 10. æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
const hasData = Object.values(taskStats).some(category => 
    Object.values(category).some(count => count > 0)
);

if (!hasData) {
    console.warn("âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼Œå›¾è¡¨å°†æ˜¾ç¤ºç©ºç™½åæ ‡");
}

// 11. ç”Ÿæˆæ—¥æœŸæ ‡ç­¾ï¼ˆä¼˜åŒ–å¯è¯»æ€§ï¼‰
function getDateLabels(dates) {
    if (dates.length === 0) return [];
    
    const start = moment(dates[0]);
    const end = moment(dates[dates.length-1]);
    const daysDiff = end.diff(start, 'days');
    
    if (daysDiff <= 14) {
        // ä¸¤å‘¨å†…ï¼šæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map(date => {
            const dateObj = moment(date);
            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
            return `${dateObj.format('MM-DD')}(${dayOfWeek})`;
        });
    } else if (daysDiff <= 31) {
        // ä¸€ä¸ªæœˆå†…ï¼šéš”å¤©æ˜¾ç¤º
        return dates.map((date, index) => {
            if (index % 2 === 0) {
                const dateObj = moment(date);
                return dateObj.format('MM-DD');
            }
            return '';
        });
    } else {
        // æ›´é•¿æ—¶é—´ï¼šæ¯å‘¨æ˜¾ç¤º
        return dates.map((date, index) => {
            if (index % 7 === 0) {
                const dateObj = moment(date);
                return dateObj.format('MM-DD');
            }
            return '';
        });
    }
}

// 12. åˆ›å»ºå›¾è¡¨
function createChart() {
    // æ˜¾ç¤ºæ ‡é¢˜
    dv.header(3, `ğŸ“ˆ ä»»åŠ¡è¶‹åŠ¿åˆ†æ (${moment(startDate).format('YYYY-MM-DD')} è‡³ ${moment(endDate).format('YYYY-MM-DD')})`);
    
    // æ£€æŸ¥Chartsæ’ä»¶æ˜¯å¦å¯ç”¨
    if (typeof window.renderChart === 'undefined') {
        dv.paragraph("âš ï¸ **Chartsæ’ä»¶æœªå¯ç”¨** - è¯·å®‰è£…å¹¶å¯ç”¨ Obsidian Charts æ’ä»¶");
        return;
    }
    
    // å‡†å¤‡æ—¥æœŸæ ‡ç­¾
    const dateLabels = getDateLabels(dateRange);
    
    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const chartData = {
        type: 'line',
        data: {
            labels: dateLabels,
            datasets: [
                {
                    label: 'â• åˆ›å»ºæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['åˆ›å»ºæ—¥æœŸ'][date]),
                    borderColor: '#3B82F6', // è“è‰²
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 5,
                    pointBackgroundColor: '#3B82F6',
                    pointHoverRadius: 7
                },
                {
                    label: 'ğŸ æ–¹æ¡ˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date]),
                    borderColor: '#F59E0B', // æ©™è‰²
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.2,
                    pointRadius: 5,
                    pointBackgroundColor: '#F59E0B',
                    pointHoverRadius: 7
                },
                {
                    label: 'âœ… å®Œæˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['å®Œæˆæ—¥æœŸ'][date]),
                    borderColor: '#10B981', // ç»¿è‰²
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 5,
                    pointBackgroundColor: '#10B981',
                    pointHoverRadius: 7
                },
                {
                    label: 'ğŸ”„ é‡å¤æ¬¡æ•°',
                    data: dateRange.map(date => taskStats['é‡å¤æ¬¡æ•°'][date]),
                    borderColor: '#EF4444', // çº¢è‰²
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 5,
                    pointBackgroundColor: '#EF4444',
                    pointHoverRadius: 7,
                    yAxisID: 'y' // ä½¿ç”¨ä¸»Yè½´
                },
                {
                    label: 'â±ï¸ ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                    data: dateRange.map(date => taskStats['ä¸“æ³¨æ—¶é•¿'][date]),
                    borderColor: '#8B5CF6', // ç´«è‰²
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 5,
                    pointBackgroundColor: '#8B5CF6',
                    pointHoverRadius: 7,
                    yAxisID: 'y1' // ä½¿ç”¨æ¬¡Yè½´
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: 12,
                        padding: 10,
                        font: {
                            size: 11,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                        },
                        usePointStyle: true
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0, 0, 0, 0.85)',
                    titleFont: { 
                        size: 12,
                        family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                    },
                    bodyFont: { 
                        size: 11,
                        family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                    },
                    padding: 10,
                    cornerRadius: 6,
                    callbacks: {
                        title: function(tooltipItems) {
                            const dateIndex = tooltipItems[0].dataIndex;
                            const date = dateRange[dateIndex];
                            const dateObj = moment(date);
                            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
                            return `${dateObj.format('YYYY-MM-DD')} (æ˜ŸæœŸ${dayOfWeek})`;
                        },
                        label: function(context) {
                            let label = context.dataset.label || '';
                            let value = context.parsed.y;
                            
                            if (label.includes('ä¸“æ³¨æ—¶é•¿')) {
                                return `${label}: ${value.toFixed(2)} å°æ—¶`;
                            } else if (label.includes('é‡å¤æ¬¡æ•°')) {
                                return `${label}: ${value} æ¬¡`;
                            } else {
                                return `${label}: ${value} ä¸ª`;
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.08)',
                        drawBorder: false
                    },
                    ticks: {
                        font: {
                            size: 10,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                        },
                        maxRotation: 45,
                        minRotation: 0,
                        color: 'var(--text-muted)'
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)',
                        drawBorder: false
                    },
                    ticks: {
                        font: {
                            size: 10,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                        },
                        stepSize: 1,
                        color: 'var(--text-muted)',
                        callback: function(value) {
                            return Number.isInteger(value) ? value : '';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä»»åŠ¡æ•°é‡ (ä¸ª)',
                        font: {
                            size: 11,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
                            weight: 'bold'
                        },
                        color: 'var(--text-normal)',
                        padding: {top: 10, bottom: 10}
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false,
                    },
                    ticks: {
                        font: {
                            size: 10,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                        },
                        color: 'var(--text-muted)',
                        callback: function(value) {
                            return value.toFixed(1) + 'h';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                        font: {
                            size: 11,
                            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif',
                            weight: 'bold'
                        },
                        color: 'var(--text-normal)',
                        padding: {top: 10, bottom: 10}
                    }
                }
            }
        }
    };
    
    // åˆ›å»ºå›¾è¡¨å®¹å™¨
    const chartContainer = this.container.createEl('div', {
        cls: 'task-trend-chart-container'
    });
    
    chartContainer.style.height = '520px';
    chartContainer.style.width = '100%';
    chartContainer.style.margin = '20px 0';
    chartContainer.style.padding = '15px';
    chartContainer.style.borderRadius = '8px';
    chartContainer.style.border = '1px solid var(--background-modifier-border)';
    chartContainer.style.backgroundColor = 'var(--background-primary)';
    chartContainer.style.boxShadow = '0 4px 12px rgba(0,0,0,0.05)';
    
    // æ¸²æŸ“å›¾è¡¨
    try {
        window.renderChart(chartData, chartContainer);
        
        // æ˜¾ç¤ºæ•°æ®æ‘˜è¦
        const summaryLines = [];
        const totalByCategory = {};
        
        Object.entries(taskStats).forEach(([category, data]) => {
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            totalByCategory[category] = total;
            
            if (total > 0) {
                if (category === 'ä¸“æ³¨æ—¶é•¿') {
                    summaryLines.push(`${category}: ${total.toFixed(2)}å°æ—¶`);
                } else if (category === 'é‡å¤æ¬¡æ•°') {
                    summaryLines.push(`${category}: ${total}æ¬¡`);
                } else {
                    summaryLines.push(`${category}: ${total}ä¸ª`);
                }
            }
        });
        
        // æ˜¾ç¤ºæ—¥æœŸç»Ÿè®¡è¯¦æƒ…
        dv.paragraph("### ğŸ“Š è¯¦ç»†ç»Ÿè®¡");
        
        let tableData = [["æ—¥æœŸ", "åˆ›å»ºæ—¥æœŸ", "æ–¹æ¡ˆæ—¥æœŸ", "å®Œæˆæ—¥æœŸ", "é‡å¤æ¬¡æ•°", "ä¸“æ³¨æ—¶é•¿(å°æ—¶)"]];
        
        dateRange.forEach(date => {
            const dateObj = moment(date);
            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
            const dateLabel = `${dateObj.format('MM-DD')}(${dayOfWeek})`;
            
            // é«˜äº®æœ‰æ•°æ®çš„è¡Œ
            const hasDataOnDate = taskStats['åˆ›å»ºæ—¥æœŸ'][date] > 0 || 
                                 taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] > 0 || 
                                 taskStats['å®Œæˆæ—¥æœŸ'][date] > 0 ||
                                 taskStats['é‡å¤æ¬¡æ•°'][date] > 0 ||
                                 taskStats['ä¸“æ³¨æ—¶é•¿'][date] > 0;
            
            tableData.push([
                hasDataOnDate ? `**${dateLabel}**` : dateLabel,
                taskStats['åˆ›å»ºæ—¥æœŸ'][date],
                taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date],
                taskStats['å®Œæˆæ—¥æœŸ'][date],
                taskStats['é‡å¤æ¬¡æ•°'][date],
                taskStats['ä¸“æ³¨æ—¶é•¿'][date].toFixed(2)
            ]);
        });
        
        dv.table(tableData[0], tableData.slice(1));
        
        if (summaryLines.length > 0) {
            dv.paragraph(`**ğŸ“ˆ æ•°æ®æ±‡æ€»**: ${summaryLines.join(' | ')}`);
        } else {
            dv.paragraph("**ğŸ“ˆ æ•°æ®æ±‡æ€»**: æš‚æ— æ•°æ®ï¼ˆæ‰€æœ‰æ—¥æœŸå‡ä¸ºç©ºç™½ï¼‰");
        }
        
        // æ˜¾ç¤ºç©ºç™½æ—¥æœŸä¿¡æ¯
        const blankDates = dateRange.filter(date => 
            taskStats['åˆ›å»ºæ—¥æœŸ'][date] === 0 && 
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] === 0 && 
            taskStats['å®Œæˆæ—¥æœŸ'][date] === 0 &&
            taskStats['é‡å¤æ¬¡æ•°'][date] === 0 &&
            taskStats['ä¸“æ³¨æ—¶é•¿'][date] === 0
        );
        
        if (blankDates.length > 0) {
            dv.paragraph(`**ğŸ“… ç©ºç™½æ—¥æœŸ**: ${blankDates.length}å¤© (${blankDates.map(d => moment(d).format('MM-DD')).join(', ')})`);
        }
        
    } catch (error) {
        console.error("âŒ å›¾è¡¨æ¸²æŸ“å¤±è´¥:", error);
        dv.paragraph("âŒ **å›¾è¡¨æ¸²æŸ“å¤±è´¥**: " + error.message);
        
        // æ˜¾ç¤ºå¤‡é€‰æ•°æ®è§†å›¾
        displayDataTable();
    }
}

// 13. æ˜¾ç¤ºæ•°æ®è¡¨æ ¼ï¼ˆå¤‡ç”¨ï¼‰
function displayDataTable() {
    dv.header(4, "ğŸ“‹ è¯¦ç»†æ•°æ®è¡¨æ ¼");
    
    let tableData = [["æ—¥æœŸ", "åˆ›å»ºæ—¥æœŸ", "æ–¹æ¡ˆæ—¥æœŸ", "å®Œæˆæ—¥æœŸ", "é‡å¤æ¬¡æ•°", "ä¸“æ³¨æ—¶é•¿(å°æ—¶)"]];
    
    dateRange.forEach(date => {
        const dateObj = moment(date);
        const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
        
        tableData.push([
            `${dateObj.format('MM-DD')}(${dayOfWeek})`,
            taskStats['åˆ›å»ºæ—¥æœŸ'][date],
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date],
            taskStats['å®Œæˆæ—¥æœŸ'][date],
            taskStats['é‡å¤æ¬¡æ•°'][date],
            taskStats['ä¸“æ³¨æ—¶é•¿'][date].toFixed(2)
        ]);
    });
    
    dv.table(tableData[0], tableData.slice(1));
}

// 14. æ‰§è¡Œä¸»å‡½æ•°
try {
    console.log("ğŸš€ å¼€å§‹æ‰§è¡Œä»»åŠ¡è¶‹åŠ¿åˆ†æ...");
    console.log(`ğŸ“… æ—¥æœŸèŒƒå›´: ${dateRange[0]} è‡³ ${dateRange[dateRange.length-1]} (å…±${dateRange.length}å¤©)`);
    console.log(`ğŸ“ ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
    
    createChart.call(this);
    
    console.log("âœ… ä»»åŠ¡è¶‹åŠ¿åˆ†æå®Œæˆ");
} catch (error) {
    console.error("âŒ æ‰§è¡Œå¤±è´¥:", error);
    dv.paragraph("âŒ **ä»£ç æ‰§è¡Œå¤±è´¥**: " + error.message);
    
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    dv.paragraph("**è°ƒè¯•ä¿¡æ¯**:");
    dv.paragraph(`- æ—¥æœŸèŒƒå›´: ${dateRange.length} å¤©`);
    dv.paragraph(`- ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
}
```

```dataviewjs
// ==================== ä»»åŠ¡è¶‹åŠ¿æŠ˜çº¿å›¾ï¼ˆå·²ä¼˜åŒ–ï¼‰ ====================
// ä¿®å¤ï¼šæ˜¾ç¤ºç©ºç™½åæ ‡ï¼Œå¯è¯»æ€§ä¼˜åŒ–ï¼Œæ­£ç¡®ç»Ÿè®¡ä»»åŠ¡è¶‹åŠ¿

// 1. è·å–å½“å‰ç¬”è®°çš„æ—¥æœŸèŒƒå›´
const currentFile = dv.current();
const startDate = currentFile['è¿›è¡Œæ—¥æœŸ'] ? dv.date(currentFile['è¿›è¡Œæ—¥æœŸ']) : dv.date('2021-01-01');
const endDate = currentFile['æˆªæ­¢æ—¥æœŸ'] ? dv.date(currentFile['æˆªæ­¢æ—¥æœŸ']) : dv.date('2021-01-30');

// 2. ç”Ÿæˆæ—¥æœŸèŒƒå›´å†…çš„æ‰€æœ‰æ—¥æœŸï¼ˆç¡®ä¿åŒ…å«ç©ºç™½åæ ‡ï¼‰
function getDateRange(start, end) {
    const dates = [];
    let current = dv.date(start);
    const endDateObj = dv.date(end);
    
    while (current <= endDateObj) {
        dates.push(current.toISODate());
        current = current.plus({ days: 1 });
    }
    return dates;
}

// 3. è·å–æ‰€æœ‰ä»»åŠ¡ï¼ˆä»å½“å‰æ–‡ä»¶ï¼‰
function getAllTasks() {
    try {
        const currentFileTasks = dv.current().file.tasks || [];
        console.log(`ğŸ“‹ æ‰¾åˆ° ${currentFileTasks.length} ä¸ªä»»åŠ¡`);
        return currentFileTasks;
    } catch (error) {
        console.error("âŒ è·å–ä»»åŠ¡å¤±è´¥:", error);
        return [];
    }
}

// 4. æå–æ—¥æœŸå‡½æ•°ï¼ˆä¼˜åŒ–å¯è¯»æ€§ï¼‰
function extractDate(text, pattern) {
    const match = text.match(pattern);
    return match ? match[1] : null;
}

// 5. æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
function extractRepeatCount(text) {
    const repeatMatch = text.match(/\+(\d+)æ¬¡/);
    return repeatMatch ? parseInt(repeatMatch[1]) : 0;
}

// 6. æå–ä¸“æ³¨æ—¶é•¿ï¼ˆä¿®å¤ï¼šä»å¤šä¸ªæ¥æºæå–ï¼‰
function extractFocusDuration(text) {
    let totalHours = 0;
    
    // æ–¹æ³•1ï¼šä»ã€â³HH:MM:SSã€‘æ ¼å¼æå–
    const focusMatch = text.match(/ã€â³(\d{2}):(\d{2}):(\d{2})ã€‘/);
    if (focusMatch) {
        const hours = parseInt(focusMatch[1]);
        const minutes = parseInt(focusMatch[2]);
        const seconds = parseInt(focusMatch[3]);
        totalHours += hours + minutes/60 + seconds/3600;
    }
    
    // æ–¹æ³•2ï¼šä»data-durå±æ€§æå–ï¼ˆç§’è½¬å°æ—¶ï¼‰
    const durMatch = text.match(/data-dur="(\d+)"/);
    if (durMatch) {
        const seconds = parseInt(durMatch[1]);
        totalHours += seconds / 3600;
    }
    
    return totalHours;
}

// ä¸»æ‰§è¡Œé€»è¾‘
const allTasks = getAllTasks();
const dateRange = getDateRange(startDate, endDate);

// 7. åˆå§‹åŒ–ç»Ÿè®¡æ•°æ®
const taskStats = {
    'åˆ›å»ºæ—¥æœŸ': {},    // â• æ ‡è®°
    'æ–¹æ¡ˆæ—¥æœŸ': {},    // ğŸ æ ‡è®°
    'å®Œæˆæ—¥æœŸ': {},    // âœ… æ ‡è®°
    'é‡å¤æ¬¡æ•°': {},    // +Xæ¬¡
    'ä¸“æ³¨æ—¶é•¿': {}     // â³ æ—¶é•¿
};

// åˆå§‹åŒ–æ‰€æœ‰æ—¥æœŸä¸º0ï¼ˆç¡®ä¿ç©ºç™½åæ ‡æ˜¾ç¤ºï¼‰
dateRange.forEach(date => {
    taskStats['åˆ›å»ºæ—¥æœŸ'][date] = 0;
    taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date] = 0;
    taskStats['å®Œæˆæ—¥æœŸ'][date] = 0;
    taskStats['é‡å¤æ¬¡æ•°'][date] = 0;
    taskStats['ä¸“æ³¨æ—¶é•¿'][date] = 0;
});

// 8. ç»Ÿè®¡ä»»åŠ¡æ•°æ®
allTasks.forEach((task, index) => {
    try {
        const text = task.text || '';
        const status = task.status || '';
        
        // è°ƒè¯•ä¿¡æ¯
        if (index < 5) {
            console.log(`ğŸ” å¤„ç†ä»»åŠ¡ ${index+1}: ${text.substring(0, 80)}...`);
        }
        
        // 1. æå–åˆ›å»ºæ—¥æœŸï¼ˆâ•æ ‡è®°ï¼‰
        const createDate = extractDate(text, /â•\s*(\d{4}-\d{2}-\d{2})/);
        if (createDate && dateRange.includes(createDate)) {
            taskStats['åˆ›å»ºæ—¥æœŸ'][createDate] += 1;
            console.log(`   â• åˆ›å»ºæ—¥æœŸ: ${createDate}`);
        }
        
        // 2. æå–æ–¹æ¡ˆæ—¥æœŸï¼ˆğŸæ ‡è®°ï¼‰
        const solutionDate = extractDate(text, /ğŸ\s*(\d{4}-\d{2}-\d{2})/);
        if (solutionDate && dateRange.includes(solutionDate)) {
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][solutionDate] += 1;
            console.log(`   ğŸ æ–¹æ¡ˆæ—¥æœŸ: ${solutionDate}`);
        }
        
        // 3. æå–å®Œæˆæ—¥æœŸï¼ˆâœ…æ ‡è®°ï¼‰
        const completeDate = extractDate(text, /âœ…\s*(\d{4}-\d{2}-\d{2})/);
        if (completeDate && dateRange.includes(completeDate)) {
            taskStats['å®Œæˆæ—¥æœŸ'][completeDate] += 1;
            console.log(`   âœ… å®Œæˆæ—¥æœŸ: ${completeDate}`);
        }
        
        // 4. æå–è®¡åˆ’æ—¥æœŸï¼ˆâ³æ ‡è®°ï¼‰- ç”¨äºé‡å¤æ¬¡æ•°å’Œä¸“æ³¨æ—¶é•¿
        const planDate = extractDate(text, /â³\s*(\d{4}-\d{2}-\d{2})/);
        if (planDate && dateRange.includes(planDate)) {
            // 4.1 æå–é‡å¤æ¬¡æ•°ï¼ˆä¿®å¤ï¼šæ­£ç¡®æå– +Xæ¬¡ï¼‰
            const repeatCount = extractRepeatCount(text);
            if (repeatCount > 0) {
                taskStats['é‡å¤æ¬¡æ•°'][planDate] += repeatCount;
                console.log(`   ğŸ”„ é‡å¤æ¬¡æ•°: ${planDate} -> +${repeatCount}æ¬¡`);
            }
            
            // 4.2 æå–ä¸“æ³¨æ—¶é•¿
            const focusHours = extractFocusDuration(text);
            if (focusHours > 0) {
                taskStats['ä¸“æ³¨æ—¶é•¿'][planDate] += focusHours;
                console.log(`   â±ï¸ ä¸“æ³¨æ—¶é•¿: ${planDate} -> ${focusHours.toFixed(2)}å°æ—¶`);
            }
        }
        
    } catch (error) {
        console.error(`âŒ å¤„ç†ä»»åŠ¡æ—¶å‡ºé”™: ${error.message}`);
    }
});

// 9. æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
const hasData = Object.values(taskStats).some(category => 
    Object.values(category).some(count => count > 0)
);

// å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä½†ä¸å¡«å……ç¤ºä¾‹æ•°æ®ï¼ˆä¿æŒç©ºç™½åæ ‡ï¼‰
if (!hasData) {
    console.warn("âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼Œå°†æ˜¾ç¤ºç©ºç™½å›¾è¡¨");
}

// 10. ç”Ÿæˆæ—¥æœŸæ ‡ç­¾ï¼ˆä¼˜åŒ–å¯è¯»æ€§ï¼‰
function getDateLabels(dates) {
    if (dates.length === 0) return [];
    
    const start = moment(dates[0]);
    const end = moment(dates[dates.length-1]);
    const daysDiff = end.diff(start, 'days');
    
    if (daysDiff <= 7) {
        // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map(date => {
            const dateObj = moment(date);
            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
            return `${dateObj.format('MM-DD')}(${dayOfWeek})`;
        });
    } else if (daysDiff <= 31) {
        // ä¸€ä¸ªæœˆå†…ï¼šæ˜¾ç¤ºæ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map((date, index) => {
            if (index % 2 === 0) {
                const dateObj = moment(date);
                return dateObj.format('MM-DD');
            }
            return '';
        });
    } else {
        // æ›´é•¿æ—¶é—´ï¼šæ¯å‘¨æ˜¾ç¤ºä¸€ä¸ªç‚¹
        const labels = [];
        for (let i = 0; i < dates.length; i += 7) {
            const dateObj = moment(dates[i]);
            labels.push(dateObj.format('MM-DD'));
        }
        return labels;
    }
}

// 11. åˆ›å»ºå›¾è¡¨
function createChart() {
    // æ˜¾ç¤ºæ ‡é¢˜
    dv.header(3, `ğŸ“ˆ ä»»åŠ¡è¶‹åŠ¿åˆ†æ (${moment(startDate).format('YYYY-MM-DD')} è‡³ ${moment(endDate).format('YYYY-MM-DD')})`);
    
    // æ£€æŸ¥Chartsæ’ä»¶æ˜¯å¦å¯ç”¨
    if (typeof window.renderChart === 'undefined') {
        dv.paragraph("âš ï¸ **Chartsæ’ä»¶æœªå¯ç”¨** - è¯·å®‰è£…å¹¶å¯ç”¨ Obsidian Charts æ’ä»¶");
        return;
    }
    
    // å‡†å¤‡æ—¥æœŸæ ‡ç­¾
    const dateLabels = getDateLabels(dateRange);
    
    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const chartData = {
        type: 'line',
        data: {
            labels: dateLabels,
            datasets: [
                {
                    label: 'â• åˆ›å»ºæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['åˆ›å»ºæ—¥æœŸ'][date]),
                    borderColor: '#3B82F6', // è“è‰²
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#3B82F6'
                },
                {
                    label: 'ğŸ æ–¹æ¡ˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date]),
                    borderColor: '#F59E0B', // æ©™è‰²
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#F59E0B'
                },
                {
                    label: 'âœ… å®Œæˆæ—¥æœŸ',
                    data: dateRange.map(date => taskStats['å®Œæˆæ—¥æœŸ'][date]),
                    borderColor: '#10B981', // ç»¿è‰²
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#10B981'
                },
                {
                    label: 'ğŸ”„ é‡å¤æ¬¡æ•°',
                    data: dateRange.map(date => taskStats['é‡å¤æ¬¡æ•°'][date]),
                    borderColor: '#EF4444', // çº¢è‰²
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#EF4444'
                },
                {
                    label: 'â±ï¸ ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                    data: dateRange.map(date => taskStats['ä¸“æ³¨æ—¶é•¿'][date]),
                    borderColor: '#8B5CF6', // ç´«è‰²
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.2,
                    pointRadius: 4,
                    pointBackgroundColor: '#8B5CF6',
                    yAxisID: 'y1'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: 12,
                        padding: 10,
                        font: {
                            size: 11
                        },
                        usePointStyle: true
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleFont: { size: 12 },
                    bodyFont: { size: 11 },
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            let value = context.parsed.y;
                            
                            if (label.includes('ä¸“æ³¨æ—¶é•¿')) {
                                return `${label}: ${value.toFixed(2)} å°æ—¶`;
                            } else if (label.includes('é‡å¤æ¬¡æ•°')) {
                                return `${label}: ${value} æ¬¡`;
                            } else {
                                return `${label}: ${value} ä¸ª`;
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        maxRotation: 45,
                        minRotation: 0
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        stepSize: 1,
                        callback: function(value) {
                            return Number.isInteger(value) ? value : '';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä»»åŠ¡æ•°é‡',
                        font: {
                            size: 11
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false,
                    },
                    ticks: {
                        font: {
                            size: 10
                        },
                        callback: function(value) {
                            return value.toFixed(1) + 'h';
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä¸“æ³¨æ—¶é•¿ (å°æ—¶)',
                        font: {
                            size: 11
                        }
                    }
                }
            }
        }
    };
    
    // åˆ›å»ºå›¾è¡¨å®¹å™¨
    const chartContainer = this.container.createEl('div', {
        cls: 'task-trend-chart-container'
    });
    
    chartContainer.style.height = '500px';
    chartContainer.style.width = '100%';
    chartContainer.style.margin = '15px 0';
    chartContainer.style.padding = '10px';
    chartContainer.style.borderRadius = '6px';
    chartContainer.style.border = '1px solid var(--background-modifier-border)';
    chartContainer.style.backgroundColor = 'var(--background-primary)';
    chartContainer.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
    
    // æ¸²æŸ“å›¾è¡¨
    try {
        window.renderChart(chartData, chartContainer);
        
        // æ˜¾ç¤ºæ•°æ®æ‘˜è¦
        const summaryLines = [];
        Object.entries(taskStats).forEach(([category, data]) => {
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            if (total > 0) {
                if (category === 'ä¸“æ³¨æ—¶é•¿') {
                    summaryLines.push(`${category}: ${total.toFixed(2)}å°æ—¶`);
                } else if (category === 'é‡å¤æ¬¡æ•°') {
                    summaryLines.push(`${category}: ${total}æ¬¡`);
                } else {
                    summaryLines.push(`${category}: ${total}ä¸ª`);
                }
            }
        });
        
        if (summaryLines.length > 0) {
            dv.paragraph(`ğŸ“Š **æ•°æ®æ‘˜è¦**: ${summaryLines.join(' | ')}`);
        } else {
            dv.paragraph("ğŸ“Š **æ•°æ®æ‘˜è¦**: æš‚æ— æ•°æ®");
        }
        
        // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
        if (!hasData) {
            dv.paragraph("â„¹ï¸ **æç¤º**: å½“å‰æ²¡æœ‰æ‰¾åˆ°ä»»åŠ¡æ•°æ®ã€‚è¯·ç¡®ä¿ï¼š");
            dv.paragraph("1. ä»»åŠ¡æ ¼å¼æ­£ç¡®ï¼ˆåŒ…å«â•ã€ğŸã€âœ…ã€â³ã€+Xæ¬¡ç­‰æ ‡è®°ï¼‰");
            dv.paragraph("2. æ—¥æœŸåœ¨æŒ‡å®šèŒƒå›´å†…ï¼ˆ2021-01-01 è‡³ 2021-01-30ï¼‰");
            dv.paragraph("3. å›¾è¡¨å°†æ˜¾ç¤ºç©ºç™½åæ ‡ï¼Œç›´åˆ°æœ‰æ•°æ®");
        }
        
    } catch (error) {
        console.error("âŒ å›¾è¡¨æ¸²æŸ“å¤±è´¥:", error);
        dv.paragraph("âŒ **å›¾è¡¨æ¸²æŸ“å¤±è´¥**: " + error.message);
        displayDataTable();
    }
}

// 12. æ˜¾ç¤ºæ•°æ®è¡¨æ ¼ï¼ˆå¤‡ç”¨ï¼‰
function displayDataTable() {
    dv.header(4, "ğŸ“‹ è¯¦ç»†æ•°æ®è¡¨æ ¼");
    
    let tableData = [["æ—¥æœŸ", "åˆ›å»ºæ—¥æœŸ", "æ–¹æ¡ˆæ—¥æœŸ", "å®Œæˆæ—¥æœŸ", "é‡å¤æ¬¡æ•°", "ä¸“æ³¨æ—¶é•¿(å°æ—¶)"]];
    
    dateRange.forEach(date => {
        const dateObj = moment(date);
        const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
        
        tableData.push([
            `${dateObj.format('MM-DD')}(${dayOfWeek})`,
            taskStats['åˆ›å»ºæ—¥æœŸ'][date],
            taskStats['æ–¹æ¡ˆæ—¥æœŸ'][date],
            taskStats['å®Œæˆæ—¥æœŸ'][date],
            taskStats['é‡å¤æ¬¡æ•°'][date],
            taskStats['ä¸“æ³¨æ—¶é•¿'][date].toFixed(2)
        ]);
    });
    
    dv.table(tableData[0], tableData.slice(1));
}

// 13. æ‰§è¡Œä¸»å‡½æ•°
try {
    console.log("ğŸš€ å¼€å§‹æ‰§è¡Œä»»åŠ¡è¶‹åŠ¿åˆ†æ...");
    console.log(`ğŸ“… æ—¥æœŸèŒƒå›´: ${dateRange[0]} è‡³ ${dateRange[dateRange.length-1]} (å…±${dateRange.length}å¤©)`);
    console.log(`ğŸ“ ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
    
    createChart.call(this);
    
    console.log("âœ… ä»»åŠ¡è¶‹åŠ¿åˆ†æå®Œæˆ");
} catch (error) {
    console.error("âŒ æ‰§è¡Œå¤±è´¥:", error);
    dv.paragraph("âŒ **ä»£ç æ‰§è¡Œå¤±è´¥**: " + error.message);
    
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    dv.paragraph("**è°ƒè¯•ä¿¡æ¯**:");
    dv.paragraph(`- æ—¥æœŸèŒƒå›´: ${dateRange.length} å¤©`);
    dv.paragraph(`- ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
}
```

```dataviewjs
// ==================== ä»»åŠ¡è¶‹åŠ¿æŠ˜çº¿å›¾ï¼ˆé€‚é…ä½ çš„æ ¼å¼ï¼‰ ====================

// 1. è·å–å½“å‰ç¬”è®°çš„æ—¥æœŸèŒƒå›´
const currentFile = dv.current();
const startDate = currentFile['è¿›è¡Œæ—¥æœŸ'] ? dv.date(currentFile['è¿›è¡Œæ—¥æœŸ']) : dv.date('2025-12-01');
const endDate = currentFile['æˆªæ­¢æ—¥æœŸ'] ? dv.date(currentFile['æˆªæ­¢æ—¥æœŸ']) : dv.date('2025-12-07');

// 2. ç”Ÿæˆæ—¥æœŸèŒƒå›´å†…çš„æ‰€æœ‰æ—¥æœŸ
function getDateRange(start, end) {
    const dates = [];
    let current = dv.date(start);
    const endDateObj = dv.date(end);
    
    while (current <= endDateObj) {
        dates.push(current.toISODate());
        current = current.plus({ days: 1 });
    }
    return dates;
}

// 3. è·å–æ‰€æœ‰ä»»åŠ¡
function getAllTasks() {
    try {
        // è·å–å½“å‰æ–‡ä»¶çš„æ‰€æœ‰ä»»åŠ¡
        const currentFileTasks = dv.current().file.tasks || [];
        
        // æ˜¾ç¤ºæ‰¾åˆ°çš„ä»»åŠ¡æ•°é‡
        console.log(`æ‰¾åˆ° ${currentFileTasks.length} ä¸ªä»»åŠ¡`);
        if (currentFileTasks.length > 0) {
            console.log("ä»»åŠ¡ç¤ºä¾‹:", currentFileTasks.slice(0, 3).map(t => t.text?.substring(0, 100)));
        }
        
        return currentFileTasks;
    } catch (error) {
        console.error("è·å–ä»»åŠ¡å¤±è´¥:", error);
        return [];
    }
}

const allTasks = getAllTasks();
const dateRange = getDateRange(startDate, endDate);

// 4. åˆå§‹åŒ–ç»Ÿè®¡æ•°æ® - æŒ‰ç…§ä½ çš„è¦æ±‚åˆ†ç±»
const taskStats = {
    å‘ç°é—®é¢˜: {},    // åˆ›å»ºæ—¥æœŸï¼ˆâ•æ ‡è®°ï¼‰
    å®Œæˆä»»åŠ¡: {},    // å®Œæˆæ—¥æœŸï¼ˆâœ…æ ‡è®°ï¼‰
    ç»™å‡ºæ–¹æ¡ˆ: {},    // æ–¹æ¡ˆæ—¥æœŸï¼ˆğŸæ ‡è®°ï¼‰
    é‡å¤æ¬¡æ•°: {},    // è®¡åˆ’æ—¥æœŸï¼ˆâ³æ ‡è®°ï¼‰+Xæ¬¡
    ä¸“æ³¨æ—¶é•¿: {}     // è®¡åˆ’æ—¥æœŸï¼ˆâ³æ ‡è®°ï¼‰+ä¸“æ³¨æ—¶é•¿ï¼ˆå°æ—¶ï¼‰
};

// åˆå§‹åŒ–æ‰€æœ‰æ—¥æœŸçš„æ•°æ®
dateRange.forEach(date => {
    taskStats.å‘ç°é—®é¢˜[date] = 0;
    taskStats.å®Œæˆä»»åŠ¡[date] = 0;
    taskStats.ç»™å‡ºæ–¹æ¡ˆ[date] = 0;
    taskStats.é‡å¤æ¬¡æ•°[date] = 0;
    taskStats.ä¸“æ³¨æ—¶é•¿[date] = 0;
});

// 5. ç»Ÿè®¡ä¸åŒç±»å‹çš„ä»»åŠ¡
allTasks.forEach(task => {
    try {
        const text = task.text || '';
        const status = task.status || ' ';
        
        // è°ƒè¯•ï¼šæ˜¾ç¤ºä»»åŠ¡å†…å®¹
        console.log("å¤„ç†ä»»åŠ¡:", { 
            text: text.substring(0, 100), 
            status,
            hasPlus: text.includes('â•'),
            hasCheck: text.includes('âœ…'),
            hasFlag: text.includes('ğŸ'),
            hasTimer: text.includes('â³'),
            hasRepeat: text.includes('+') && text.includes('æ¬¡')
        });
        
        // 1. æå–åˆ›å»ºæ—¥æœŸï¼ˆå‘ç°é—®é¢˜ï¼‰- â•æ ‡è®°
        const createMatch = text.match(/â•\s*(\d{4}-\d{2}-\d{2})/);
        if (createMatch) {
            const createDate = createMatch[1];
            if (dateRange.includes(createDate)) {
                taskStats.å‘ç°é—®é¢˜[createDate] = (taskStats.å‘ç°é—®é¢˜[createDate] || 0) + 1;
                console.log(`å‘ç°åˆ›å»ºæ—¥æœŸ: ${createDate} -> å‘ç°é—®é¢˜+1`);
            }
        }
        
        // 2. æå–å®Œæˆæ—¥æœŸï¼ˆå®Œæˆä»»åŠ¡ï¼‰- âœ…æ ‡è®°
        const completeMatch = text.match(/âœ…\s*(\d{4}-\d{2}-\d{2})/);
        if (completeMatch) {
            const completeDate = completeMatch[1];
            if (dateRange.includes(completeDate)) {
                taskStats.å®Œæˆä»»åŠ¡[completeDate] = (taskStats.å®Œæˆä»»åŠ¡[completeDate] || 0) + 1;
                console.log(`å‘ç°å®Œæˆæ—¥æœŸ: ${completeDate} -> å®Œæˆä»»åŠ¡+1`);
            }
        }
        
        // 3. æå–æ–¹æ¡ˆæ—¥æœŸï¼ˆç»™å‡ºæ–¹æ¡ˆï¼‰- ğŸæ ‡è®°
        const solutionMatch = text.match(/ğŸ\s*(\d{4}-\d{2}-\d{2})/);
        if (solutionMatch) {
            const solutionDate = solutionMatch[1];
            if (dateRange.includes(solutionDate)) {
                taskStats.ç»™å‡ºæ–¹æ¡ˆ[solutionDate] = (taskStats.ç»™å‡ºæ–¹æ¡ˆ[solutionDate] || 0) + 1;
                console.log(`å‘ç°æ–¹æ¡ˆæ—¥æœŸ: ${solutionDate} -> ç»™å‡ºæ–¹æ¡ˆ+1`);
            }
        }
        
        // 4. æå–è®¡åˆ’æ—¥æœŸï¼ˆç”¨äºé‡å¤æ¬¡æ•°å’Œä¸“æ³¨æ—¶é•¿ï¼‰- â³æ ‡è®°
        const planMatch = text.match(/â³\s*(\d{4}-\d{2}-\d{2})/);
        if (planMatch) {
            const planDate = planMatch[1];
            if (dateRange.includes(planDate)) {
                // ä¿®å¤ï¼šæå–é‡å¤æ¬¡æ•°ï¼ˆ+Xæ¬¡ï¼‰
                const repeatMatch = text.match(/\+(\d+)æ¬¡/);
                if (repeatMatch) {
                    const repeatCount = parseInt(repeatMatch[1]);
                    taskStats.é‡å¤æ¬¡æ•°[planDate] = (taskStats.é‡å¤æ¬¡æ•°[planDate] || 0) + repeatCount;
                    console.log(`å‘ç°è®¡åˆ’æ—¥æœŸ(é‡å¤): ${planDate} -> é‡å¤æ¬¡æ•°+${repeatCount}`);
                }
                
                // ä¿®å¤ï¼šæå–ä¸“æ³¨æ—¶é•¿ï¼ˆä»ã€â³HH:MM:SSã€‘æå–å°æ—¶ï¼‰
                const focusMatch = text.match(/ã€â³(\d{2}):(\d{2}):(\d{2})ã€‘/);
                if (focusMatch) {
                    // å°†æ—¶é—´å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°æ—¶æ•°
                    const hours = parseInt(focusMatch[1]);
                    const minutes = parseInt(focusMatch[2]);
                    const seconds = parseInt(focusMatch[3]);
                    
                    // è½¬æ¢ä¸ºå°æ—¶ï¼ˆä¾‹å¦‚02:00:00 = 2å°æ—¶ï¼‰
                    const totalHours = hours + minutes/60 + seconds/3600;
                    
                    taskStats.ä¸“æ³¨æ—¶é•¿[planDate] = (taskStats.ä¸“æ³¨æ—¶é•¿[planDate] || 0) + totalHours;
                    console.log(`å‘ç°è®¡åˆ’æ—¥æœŸ(ä¸“æ³¨): ${planDate} -> ä¸“æ³¨æ—¶é•¿+${totalHours}å°æ—¶`);
                }
                
                // ä¿®å¤ï¼šä»timer-pçš„data-durå±æ€§æå–æ—¶é•¿ï¼ˆç§’è½¬å°æ—¶ï¼‰
                const durMatch = text.match(/data-dur="(\d+)"/);
                if (durMatch) {
                    const seconds = parseInt(durMatch[1]);
                    const hours = seconds / 3600; // ç§’è½¬å°æ—¶
                    
                    taskStats.ä¸“æ³¨æ—¶é•¿[planDate] = (taskStats.ä¸“æ³¨æ—¶é•¿[planDate] || 0) + hours;
                    console.log(`ä»data-duræå–ä¸“æ³¨æ—¶é•¿: ${planDate} -> ${hours}å°æ—¶`);
                }
            }
        }
        
    } catch (error) {
        console.error("å¤„ç†ä»»åŠ¡æ—¶å‡ºé”™:", error);
    }
});

// 6. å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºç¤ºä¾‹æ•°æ®ç”¨äºæµ‹è¯•
const hasData = Object.values(taskStats).some(category => 
    Object.values(category).some(count => count > 0)
);

if (!hasData) {
    console.warn("æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®ï¼Œä½¿ç”¨ç¤ºä¾‹æ•°æ®");
    
    // æ·»åŠ ç¤ºä¾‹æ•°æ®
    dateRange.forEach((date, index) => {
        taskStats.å‘ç°é—®é¢˜[date] = Math.floor(Math.random() * 3) + 1;
        taskStats.å®Œæˆä»»åŠ¡[date] = Math.floor(Math.random() * 2) + 1;
        taskStats.ç»™å‡ºæ–¹æ¡ˆ[date] = Math.floor(Math.random() * 2);
        taskStats.é‡å¤æ¬¡æ•°[date] = Math.floor(Math.random() * 4) + 5; // æ¨¡æ‹Ÿ+5åˆ°+9æ¬¡
        taskStats.ä¸“æ³¨æ—¶é•¿[date] = Math.floor(Math.random() * 3) + 1; // æ¨¡æ‹Ÿ1-3å°æ—¶
    });
}

// 7. å‡†å¤‡æ—¥æœŸæ ‡ç­¾
function getDateLabels(dates) {
    const daysDiff = moment(dates[dates.length-1]).diff(moment(dates[0]), 'days');
    
    if (daysDiff <= 7) {
        // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ˜ŸæœŸ
        return dates.map(date => {
            const dateObj = moment(date);
            const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
            return `${dateObj.format('MM-DD')}(${dayOfWeek})`;
        });
    } else if (daysDiff <= 31) {
        // ä¸€ä¸ªæœˆå†…ï¼šæ¯å‘¨æ˜¾ç¤ºä¸€ä¸ªç‚¹
        const labels = [];
        for (let i = 0; i < dates.length; i += 7) {
            const dateObj = moment(dates[i]);
            labels.push(dateObj.format('MM-DD'));
        }
        return labels;
    } else {
        // æ›´é•¿æ—¶é—´ï¼šæ¯æœˆæ˜¾ç¤ºä¸€ä¸ªç‚¹
        const labels = [];
        let current = moment(dates[0]);
        const end = moment(dates[dates.length-1]);
        
        while (current <= end) {
            labels.push(current.format('MMæœˆ'));
            current = current.add(1, 'month');
        }
        return labels;
    }
}

// 8. åˆ›å»ºå›¾è¡¨
function createChart() {
    // æ˜¾ç¤ºæ ‡é¢˜
    dv.header(3, `ğŸ“ˆ ä»»åŠ¡è¶‹åŠ¿åˆ†æ (${moment(startDate).format('YYYY-MM-DD')} è‡³ ${moment(endDate).format('YYYY-MM-DD')})`);
    
    // æ£€æŸ¥Chartsæ’ä»¶æ˜¯å¦å¯ç”¨
    if (typeof window.renderChart === 'undefined') {
        dv.paragraph("âš ï¸ **Chartsæ’ä»¶æœªå¯ç”¨**");
        dv.paragraph("è¯·å®‰è£…å¹¶å¯ç”¨ Obsidian Charts æ’ä»¶");
        return;
    }
    
    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const chartData = {
        type: 'line',
        data: {
            labels: getDateLabels(dateRange),
            datasets: [
                {
                    label: 'ğŸ” å‘ç°é—®é¢˜ï¼ˆåˆ›å»ºæ—¥æœŸï¼‰',
                    data: dateRange.map(date => taskStats.å‘ç°é—®é¢˜[date]),
                    borderColor: '#3B82F6', // è“è‰²
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3,
                    pointRadius: 4
                },
                {
                    label: 'âœ… å®Œæˆä»»åŠ¡ï¼ˆå®Œæˆæ—¥æœŸï¼‰',
                    data: dateRange.map(date => taskStats.å®Œæˆä»»åŠ¡[date]),
                    borderColor: '#10B981', // ç»¿è‰²
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4
                },
                {
                    label: 'ğŸ“‹ ç»™å‡ºæ–¹æ¡ˆï¼ˆæ–¹æ¡ˆæ—¥æœŸï¼‰',
                    data: dateRange.map(date => taskStats.ç»™å‡ºæ–¹æ¡ˆ[date]),
                    borderColor: '#F59E0B', // æ©™è‰²
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4
                },
                {
                    label: 'ğŸ”„ é‡å¤æ¬¡æ•°ï¼ˆè®¡åˆ’æ—¥æœŸï¼‰',
                    data: dateRange.map(date => taskStats.é‡å¤æ¬¡æ•°[date]),
                    borderColor: '#EF4444', // çº¢è‰²
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4,
                    yAxisID: 'y' // ä½¿ç”¨ä¸»Yè½´
                },
                {
                    label: 'â±ï¸ ä¸“æ³¨æ—¶é•¿ï¼ˆå°æ—¶ï¼‰',
                    data: dateRange.map(date => taskStats.ä¸“æ³¨æ—¶é•¿[date]),
                    borderColor: '#8B5CF6', // ç´«è‰²
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4,
                    yAxisID: 'y1' // ä½¿ç”¨æ¬¡Yè½´ï¼ˆå› ä¸ºå•ä½ä¸åŒï¼‰
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: 10,
                        padding: 8,
                        font: {
                            size: 10
                        },
                        usePointStyle: true
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label.includes('ä¸“æ³¨æ—¶é•¿')) {
                                return `${label}: ${context.parsed.y.toFixed(2)} å°æ—¶`;
                            } else {
                                return `${label}: ${context.parsed.y} ä¸ª`;
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 9
                        },
                        maxRotation: 45
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: 9
                        },
                        stepSize: 1
                    },
                    title: {
                        display: true,
                        text: 'ä»»åŠ¡æ•°é‡',
                        font: {
                            size: 10
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    beginAtZero: true,
                    grid: {
                        drawOnChartArea: false, // é¿å…ä¸ä¸»Yè½´ç½‘æ ¼é‡å 
                    },
                    ticks: {
                        font: {
                            size: 9
                        },
                        callback: function(value) {
                            return value.toFixed(1) + 'h'; // æ˜¾ç¤ºå°æ•°å¹¶åŠ å•ä½
                        }
                    },
                    title: {
                        display: true,
                        text: 'ä¸“æ³¨æ—¶é•¿ï¼ˆå°æ—¶ï¼‰',
                        font: {
                            size: 10
                        }
                    }
                }
            }
        }
    };
    
    // åˆ›å»ºå›¾è¡¨å®¹å™¨
    const chartContainer = this.container.createEl('div', {
        cls: 'task-trend-chart'
    });
    
    chartContainer.style.height = '450px'; // å¢åŠ é«˜åº¦ä»¥å®¹çº³åŒYè½´
    chartContainer.style.width = '100%';
    chartContainer.style.margin = '10px 0';
    chartContainer.style.padding = '5px';
    chartContainer.style.borderRadius = '4px';
    chartContainer.style.border = '1px solid var(--background-modifier-border)';
    chartContainer.style.backgroundColor = 'var(--background-primary)';
    
    // æ¸²æŸ“å›¾è¡¨
    try {
        window.renderChart(chartData, chartContainer);
        
        // æ˜¾ç¤ºæ•°æ®æ‘˜è¦ï¼ˆæ ¼å¼åŒ–ä¸“æ³¨æ—¶é•¿ï¼‰
        const summary = Object.entries(taskStats).map(([category, data]) => {
            const total = Object.values(data).reduce((a, b) => a + b, 0);
            if (category === 'ä¸“æ³¨æ—¶é•¿') {
                return `${category}: ${total.toFixed(2)}å°æ—¶`;
            }
            return `${category}: ${total}`;
        }).join(' | ');
        
        dv.paragraph(`ğŸ“Š **æ•°æ®æ‘˜è¦**: ${summary}`);
        
    } catch (error) {
        console.error("å›¾è¡¨æ¸²æŸ“å¤±è´¥:", error);
        dv.paragraph("âŒ **å›¾è¡¨æ¸²æŸ“å¤±è´¥**: " + error.message);
        
        // æ˜¾ç¤ºæ•°æ®è¡¨æ ¼ä½œä¸ºå¤‡é€‰
        displayDataTable();
    }
}

// 9. æ˜¾ç¤ºæ•°æ®è¡¨æ ¼ï¼ˆå¦‚æœå›¾è¡¨æ¸²æŸ“å¤±è´¥ï¼‰
function displayDataTable() {
    dv.header(4, "ğŸ“‹ è¯¦ç»†æ•°æ®");
    
    let tableData = [["æ—¥æœŸ", "å‘ç°é—®é¢˜", "å®Œæˆä»»åŠ¡", "ç»™å‡ºæ–¹æ¡ˆ", "é‡å¤æ¬¡æ•°", "ä¸“æ³¨æ—¶é•¿(å°æ—¶)"]];
    
    dateRange.forEach(date => {
        const dateObj = moment(date);
        const dayOfWeek = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'][dateObj.day()];
        
        tableData.push([
            `${dateObj.format('MM-DD')}(${dayOfWeek})`,
            taskStats.å‘ç°é—®é¢˜[date],
            taskStats.å®Œæˆä»»åŠ¡[date],
            taskStats.ç»™å‡ºæ–¹æ¡ˆ[date],
            taskStats.é‡å¤æ¬¡æ•°[date],
            taskStats.ä¸“æ³¨æ—¶é•¿[date].toFixed(2) // æ˜¾ç¤º2ä½å°æ•°
        ]);
    });
    
    dv.table(tableData[0], tableData.slice(1));
}

// 10. æ‰§è¡Œ
try {
    createChart.call(this);
} catch (error) {
    console.error("æ‰§è¡Œå¤±è´¥:", error);
    dv.paragraph("âŒ **ä»£ç æ‰§è¡Œå¤±è´¥**: " + error.message);
    
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    dv.paragraph("**è°ƒè¯•ä¿¡æ¯**:");
    dv.paragraph(`- æ—¥æœŸèŒƒå›´: ${dateRange.length} å¤© (${startDate} åˆ° ${endDate})`);
    dv.paragraph(`- ä»»åŠ¡æ•°é‡: ${allTasks.length}`);
    
    Object.entries(taskStats).forEach(([category, data]) => {
        const total = Object.values(data).reduce((a, b) => a + b, 0);
        if (category === 'ä¸“æ³¨æ—¶é•¿') {
            dv.paragraph(`- ${category}: ${total.toFixed(2)}å°æ—¶`);
        } else {
            dv.paragraph(`- ${category}: ${total}`);
        }
    });
}
```